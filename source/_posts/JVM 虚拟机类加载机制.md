---
title: JVM 虚拟机类加载机制
comments: true
categories: [Java]
tags: [Java,JVM]
https: //api.r10086.com/樱道随机图片api接口.php?图片系列=动漫综合2
cover: https://api.r10086.com/樱道随机图片api接口.php?图片系列=动漫综合2
---
> 在 Java 语言里面，类型的加载、 连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面 临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高 的扩展性和灵活性，Java 天生可以**动态扩展的语言特性**就是依赖运行期动态加载和动态 连接这个特点实现的。
>
> —— 《深入理解 JVM 虚拟机 -周志明》

### 类加载的时机

#### 七个阶段

**加载、验证、准备、解析、 初始化、使用和卸载**七个阶段，其中**验证、准 备、解析三个部分统称为连接**

![image-20231206182623171](https://ruafafa-photobed.oss-cn-beijing.aliyuncs.com/image-20231206182623171.png)

#### 特点

开始时间顺序，但是进行过程和结束时间不一定顺序



#### 必须立即对类初始化的情况

- <details>
    <summary>六个情况</summary>
    <pre>
  1) 
  	遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没
  有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型
  Java 代码场景有：
  ·使用 new 关键字实例化对象的时候。
  ·读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的
  静态字段除外）的时候。
  ·调用一个类型的静态方法的时候。
  2) 
  	使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行
  过初始化，则需要先触发其初始化。
  3) 
  	当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父
  类的初始化。
  4) 
  	当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个
  类），虚拟机会先初始化这个主类。
  5) 
  	当使用 JDK 7 新加入的动态语言支持时，如果一个
  java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、
  REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句
  柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
  6) 
  	当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方
  法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始
  化。
    </pre>
  </details>

- 对类型进行主动引用

  > 被动引用: 
  >
  > - 通过子类引用父类的静态字段，不会导致子类初始化
  > -  通过数组定义来引用类，不会触发此类的初始化，数组由虚拟机生成对用的数组类
  > - 常量(static final)在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的  类的初始化

接口不会随父类的初始化而初始化



### 类加载的过程

#### 1.加载

完成以下三件 事情 

1) 通过一个类的全限定名来获取定义此类的二进制字节流。
2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 
3) 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种 数据的访问入口。



#### 2.验证

防止有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃

验证的四个阶段检查动作：**文件格式验证、元数据验证、字节码验证和符号引用验证**



##### 文件格式验证

> 是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理

验证点

- 是否已魔数 0xCAFEBABE 开头
- 版本号是否可以接受
- 常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
- CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据
- Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息
- ......



##### 元数据验证

> 是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语 言规范》的要求

验证点

- 这个类是否有父类（除了 `java.lang.Object` 之外，所有的类都应当有父类）。 
- 这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。
-  如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 
- 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现 不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 
- …



##### 字节码验证

> 是通过数据流分析和控制 流分析，确定程序语义是合法的、符合逻辑的

验证点

- 对类的方法体进行校验，确保不会危害虚拟机安全
- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
- 保证任何跳转指令都不会跳转到方法体以外的字节码指令上
- 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据 类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无 继承关系、完全不相干的一个数据类型，则是危险和不合法
- ......

::book:通过字节码验证的类型不一定是安全的，应为即**不能通过程序准确地检查 出程序**是否能在有限的时间之内结束运行



##### 符号引用验证

> 在虚拟机将符号引用转化为直接引用的时候，这个 转化动作将在连接的第三阶段——解析阶段中发生，详细见下文
>
> 可以看作是对类自身 以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，**该类是 否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验 下列内容：**

校验点：

- 符号引用中通过字符串描述的全限定名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
- 符号引用中的类、字段、方法的可访问性（private、protected、public、 ）是否可被当前类访问

:book: 非常重要的、但却不是必须要执行 的阶段，如果是已经反复验证过的代码，可以使用 -Xverify: none 参数关闭类验证措施



#### 3.准备

> 正式为类中定义的变量（即静态变量，被 static 修饰的变量）分配内存 并设置类变量初始值的阶段

:book:

- 在 JDK 8 及之后，类变量（被 static 修饰的）则会随着 Class 对象一起存放在 Java 堆中

- 这里的初始值是“通常情况”指数据类型的零值，如

  `public static int value = 123;`，准备阶段后初始值为 0 而不是 123，应为还没有执行 Java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器 ()方法之中，所以把 value 赋值为 123 的动作要到类的初始化阶段才会被执行。

  “特殊情 况”：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量值就会被 初始化为 ConstantValue 属性所指定的初始值，假设上面类变量 value 的定义修改为： `public static final int value = 123;` 编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 Con-stantValue 的设置将 value 赋值为 123



#### 4.解析

> 将常量池内的符号引用替换为直接引用的过程

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调 用点限定符这 7 类符号引用进行，分别对应于常量池的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、 CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info 和 CONSTANT_InvokeDynamic_info 8 种常量类型



#### 5.初始化

> 初始化阶段，Java 虚拟机才真正开始执行类中编写 的 Java 程序代码，将主导权移交给应用程序

初始化阶段就是执行类构造器\<clinit>()方法的过程。\<clinit>()并不是程序员在 Java 代码中直接编写的方法，它是 Javac 编译器的自动生成 物

- \<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块 （static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序 决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变 量，在前面的静态语句块可以赋值，但是不能访问

```java
public class Test { 
    static { 
        i = 0; // 给变量复制可以正常编译通过 
        System.out.print(i); // 这句编译器会提示“非法向前引用” 
    } 

	static int i = 1;
}
```

- Java 虚拟机必须保证一个类的()方法在多线程环境中被正确地加锁同步，如 果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的()方 法，其他线程都需要阻塞等待，直到活动线程执行完毕()方法



#### 

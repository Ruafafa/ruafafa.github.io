---
title: JVM 虚拟机字节码执行引擎
comments: true
categories: [Java]
tags: [Java,JVM]
https: //api.r10086.com/樱道随机图片api接口.php?图片系列=动漫综合2
cover: https://api.r10086.com/樱道随机图片api接口.php?图片系列=动漫综合2
---
## 运行时栈帧结构

**Java 虚拟机以<u>方法</u>作为最基本的执行单元**

**而  <u>“栈帧”（Stack Frame）</u>是用于支持虚 拟机进行方法调用和方法执行背后的数据结构它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）[1]的栈元素**

**栈帧存储**了方法的==局部变量表、操作数栈、动态连接和方法返回地址==等信息

![image-20231209004841870](https://ruafafa-photobed.oss-cn-beijing.aliyuncs.com/image-20231209004841870.png)

![image-20231209005014203](https://ruafafa-photobed.oss-cn-beijing.aliyuncs.com/image-20231209005014203.png)

### 局部变量表

#### 定义

是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量

#### 容量

局部变量表的容量以变量槽（Variable Slot）为最小单位、

#### 开发影响

局部变量不像前面介 绍的类变量那样存在“准备阶段”，如果一个局 部变量定义了但没有赋初始值，那它是完全不能使用的



### 操作数栈

LIDO 后入先出的栈

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程 中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的 时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一 点

在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重 叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅 节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行 额外的参数复制传递了

**![image-20231209012304452](https://ruafafa-photobed.oss-cn-beijing.aliyuncs.com/image-20231209012304452.png)**

### 动态连接

每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用 是为了支持方法调用过程中的动态连接（Dynamic Linking）。

> "运行时常量池"（Runtime Constant Pool）是 Java 虚拟机（JVM）中的一部分，用于存储字符串常量、符号引用等信息。在 Java 中，常量池是一组常量的集合，包括类文件常量池和运行时常量池。
>
> 1. **类文件常量池：** 在 Java 编译时，每个类的常量池都被存储在类文件中，包括类的字段和方法的符号引用、字面值常量等。这部分常量池在类加载时被加载到 JVM 中。
> 2. **运行时常量池：** 在类加载后，类文件常量池的信息被加载到运行时常量池中，以供运行时使用。运行时常量池是方法区（Method Area）的一部分。
>
> 运行时常量池存储的主要内容包括：
>
> - **字符串常量：** 存储在字符串常量池中的字符串字面值。
> - **符号引用：** 类和方法的符号引用。
> - **类和方法的字面值常量：** 如字面值常量、静态变量等。

### 方法返回地址

方法退出两种方式

- 遇到方法返回字节码指令 ：“正常调用完成”
- 遇到了异常，并且这个异常没有在方法体 内得到妥善处理：“异常调用完成”

### 附加信息

《Java 虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中， 例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不 再详述。在讨论概念时，一般会把动态连接、方法返回地址与其他附加信息全部归为一 类，称为栈帧信息

## 方法调用

方法调用阶段唯一的任务就是确定被调 用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程

### 解析

调用目标在程序代码 写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析.

解析的主要有对 **静态方法 和私有方法** 两大类的解析

### 分派

按照分派依据的宗量数可分为单分派和多分派[1]。这两类分派方式两两组合就 构成了静态单分派、静态多分派、动态单分派、动态多分派 4 种分派组合情况

#### 静态分派

所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的 最典型应用表现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实 际上不是由虚拟机来执行的，这点也是为何一些资料选择把它归入“解析”而不是“分派” 的原因。

分派只能确定一个“相对更合适的”版本，一般来说匹配范围从小到大，从精确到普遍，但是**变长参数的匹配优先级是最低的**，**当匹配优先级相同时，编译器无法确定自动转型的类型，就会提示“类型模糊”，并拒绝编译们需要手动指定**

#### 动态分派

正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所 以两次调用中的 invokevirtual 指令并不是把常量池中方法的符号引用解析到直接引用上 就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是 Java 语言中 方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为 动态分派

值得注意的的是：字段不具备多态性，它们在编译时就已经确定。而方法的调用是多态的，它在运行时根据实际对象的类型确定。

#### 单分派与多分派

**方法的接收者与方法的参数统称为方法的宗量**，这个定义最早应该来源于著名的 《Java 与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两 种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标 方法进行选择

Java 语言 的静态分派属于多分派类型：根据接收者和方法参数确定选择，产生指令

Java 语言 的动态分派属于单分派类型：根据确定好的指令，产生结果



## 动态类型语言支持

### 动态类型语言

- **特点：** 在动态类型语言中，变量的类型是在运行时（runtime）而不是在编译时（compile time）确定的。这意味着你可以在运行时改变变量的类型，而不需要提前声明类型。
- **示例：** Python、JavaScript、Ruby 等是动态类型语言的例子。

### java.lang.invoke包

于 JDK7 引入

与 java.lang.reflect 相比，拥有更好的性能和更安全的反射操作

### invokedynamic指令

每一处含有 invokedynamic 指令的位置都被称作“动态调用点（DynamicallyComputed Call Site）”，这条指令的第一个参数不再是代表方法符号引用的 CONSTANT_Methodref_info 常量，而是变为 JDK 7 时新加入的 CONSTANT_InvokeDynamic_info 常量，从这个新常量中可以得到 3 项信息：引导方法 （Bootstrap Method，该方法存放在新增的 BootstrapMethods 属性中）、方法类型 （MethodType）和名称。引导方法是有固定的参数，并且返回值规定是 java.lang.invoke.CallSite 对象，这个对象代表了真正要执行的目标方法调用。根据 CONSTANT_InvokeDynamic_info 常量中提供的信息，虚拟机可以找到并且执行引导方 法，从而获得一个 CallSite 对象，最终调用到要执行的目标方法上。

### 方法分派规则

invokedynamic 指令与此前 4 条传统的“invoke*”指令的最大区别就是它的分派逻辑 不是由虚拟机决定的，而是由程序员决定



## 基于栈的字节码解释执行引擎

### 解释执行

![image-20231210011327113](https://ruafafa-photobed.oss-cn-beijing.aliyuncs.com/image-20231210011327113.png)

### 基于栈的指令集与基于寄存器的指令集

#### 差别

基于栈的指令集主要优点是可移植，因为寄存器由硬件直接提供，由虚 拟机实现来自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存等）放到寄存器 中以获取尽量好的性能，这样实现起来也更简单一些，还有一些其他的 优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还 需要存放参数）、编译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈 上操作）等。

栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些，所有主流物

#### 执行

1. **解释器初始化：** 解释器开始执行时，会初始化一个操作数栈（operand stack）和一个帧栈（frame stack）。
2. **方法调用：** 当执行一个方法时，解释器会创建一个新的帧（frame）并将其推送到帧栈。每个帧都包含了方法的局部变量表、操作数栈、和一些其他执行状态的信息。
3. **指令解码：** 解释器从当前执行的方法的字节码中取出一条指令。
4. **指令执行：** 根据指令的类型，解释器执行相应的操作。这可能涉及到对操作数栈的修改、对局部变量表的访问、方法调用等。
5. **跳转和分支：** 某些指令可能导致程序的控制流发生变化，例如条件分支、循环等。解释器会根据这些指令调整程序计数器，使程序跳转到正确的位置。
6. **操作数栈管理：** 很多指令都涉及到对操作数栈的操作，包括压栈（push）和弹栈（pop）等。解释器会根据指令对操作数栈进行相应的操作。
7. **方法返回：** 当方法执行完毕或者遇到返回指令时，解释器从帧栈中弹出当前帧，将控制流返回到调用该方法的位置。
8. **异常处理：** 在执行过程中，如果发生异常，解释器会根据异常处理机制进行相应的处理，可能是跳转到异常处理代码块或者将异常传播给上层。





